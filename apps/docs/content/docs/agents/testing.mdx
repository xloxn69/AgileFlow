---
title: Testing
description: Testing specialist for test strategy, test patterns, coverage optimization, and comprehensive test suite design.
---

# Testing Agent

The Testing Agent (AG-TESTING) is a specialized quality assurance expert who designs comprehensive test strategies, eliminates testing anti-patterns, and optimizes test coverage. Unlike CI infrastructure setup, this agent focuses on the "what to test" and "how to test it" questions.

## Capabilities

- **Test Strategy Design**: Create comprehensive test plans covering unit, integration, and E2E testing
- **Coverage Optimization**: Analyze code coverage and identify gaps in critical paths
- **Test Anti-Pattern Detection**: Identify and eliminate flaky, slow, and brittle tests
- **Test Infrastructure**: Create test fixtures, factories, and helper functions
- **Coverage Analysis**: Measure and report coverage metrics with actionable recommendations
- **Test Pattern Documentation**: Document reusable testing patterns and best practices
- **Performance Testing**: Design and execute performance benchmarks
- **Mutation Testing**: Test the tests themselves to ensure quality

## When to Use

Use the Testing Agent when:

- Starting a new feature and need to define what needs testing
- Current test coverage is below 70% and needs improvement
- Tests are flaky (intermittent failures) or slow (>1 second each)
- Need to design test fixtures or factories for complex test data
- Setting up automated testing infrastructure
- Creating ADRs for testing decisions
- Implementing comprehensive test suites for critical paths

## How It Works

1. **Knowledge Loading**: Agent reads expertise file and project testing state
2. **Story Review**: Agent analyzes story for testability requirements
3. **Test Planning**: Agent designs test cases (happy path, error cases, edge cases)
4. **Infrastructure Setup**: Agent creates test fixtures, mocks, and helpers
5. **Test Implementation**: Agent writes tests following AAA pattern (Arrange-Act-Assert)
6. **Coverage Measurement**: Agent measures coverage and identifies gaps
7. **Anti-Pattern Elimination**: Agent identifies and fixes flaky/slow/brittle tests
8. **Verification**: Agent runs `/agileflow:verify` to ensure all tests pass
9. **Coordination**: Agent updates status.json and communicates via bus/log.jsonl

## Example

```bash
# Via babysit - identify testing work
/agileflow:babysit
> "We need comprehensive testing for the payment processing feature"

# Agent output:
# Test Strategy Created:
# - Unit tests: Payment validation, transaction formatting (80% coverage)
# - Integration tests: Database saves, external API calls (15% coverage)
# - E2E tests: Complete payment workflow (5% coverage)
# - Coverage target: 85% critical path
# - Expected test count: 47 tests
# - Estimated time: 4 hours
```

## Key Behaviors

- **AAA Pattern**: All tests follow Arrange-Act-Assert structure for clarity
- **Test Isolation**: Unit tests mock dependencies; integration tests use real dependencies
- **Behavior-Focused**: Tests validate behavior, not implementation details
- **Fast Execution**: Unit tests run in milliseconds; full suite in minutes
- **Clear Naming**: Test names describe exactly what is being tested
- **Coverage Thresholds**: 70% minimum, 80%+ for critical paths (100% for auth/payment)
- **No Flaky Tests**: Intermittent failures are red flags; randomness and timing removed
- **Performance Awareness**: Tests are not slower than the code they test
- **Context Preservation**: Uses compact_context (priority: high) to maintain testing focus during long conversations, preserving coverage targets and anti-pattern detection through context compaction

## Compact Context Configuration

The Testing agent uses **high priority** compact_context to ensure test coverage and quality stay in focus:

```yaml
compact_context:
  priority: high
  preserve_rules:
    - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/testing/expertise.yaml"
    - "AAA PATTERN: All tests follow Arrange-Act-Assert structure"
    - "COVERAGE MINIMUM: 70% coverage required, 80%+ for critical paths"
    - "NO FLAKY TESTS: Eliminate randomness, timing issues, intermittent failures"
    - "TEST ISOLATION: Unit tests mock, integration tests use real dependencies"
    - "VERIFY PASSES: Run /agileflow:verify before marking in-review"
  state_fields:
    - current_story
    - coverage_percentage
    - critical_paths_count
    - flaky_tests_found
    - test_status_baseline
```

This ensures testing-critical rules (AAA pattern, coverage minimums, anti-flaky test practices) and current state (coverage gaps, flaky test counts, critical path testing status) remain in focus through context compaction.

## Tools Available

- Read, Write, Edit (file operations)
- Bash (run test commands)
- Glob (find test files)
- Grep (search test code)

## Session Harness Integration

The Testing Agent integrates with the Session Harness to ensure quality:

```text
Pre-Implementation:
├── Check environment.json exists
├── Verify test_status: "passing" baseline
└── Run /agileflow:session:resume

During Implementation:
├── Run tests incrementally
├── Fix failures immediately
└── Update test_status in real-time

Post-Implementation:
├── Run /agileflow:verify US-XXXX (must pass)
├── Verify test_status: "passing"
└── Mark story "in-review" ONLY if tests pass
```

## Test Categories & Targets

| Category | Percentage | Speed | Scope |
|----------|-----------|-------|-------|
| Unit Tests | 80% | under 1ms each | Single function, mocked dependencies |
| Integration Tests | 15% | Slower | Multiple components, real dependencies |
| E2E Tests | 5% | Very slow | Full user workflows |
| Contract Tests | 0-5% | Fast | API schema validation |

## Quality Checklist

Before marking a story complete:

- [ ] Test coverage ≥70% (critical paths 100%)
- [ ] All happy path scenarios tested
- [ ] All error scenarios tested
- [ ] Edge cases identified and tested
- [ ] No flaky tests (run 10x, all pass)
- [ ] No slow tests (each test under 1s, full suite under 5min)
- [ ] Tests test behavior, not implementation
- [ ] Test names clearly describe what's tested
- [ ] Test fixtures reusable and well-documented
- [ ] Coverage report generated and reviewed
- [ ] test_status: "passing" verified

## Common Test Patterns

**AAA Pattern (Arrange-Act-Assert)**:
```javascript
describe('validateEmail', () => {
  it('rejects invalid formats', () => {
    // Arrange
    const email = 'invalid@';

    // Act
    const result = validateEmail(email);

    // Assert
    expect(result).toBe(false);
  });
});
```

**Test Fixtures (Reusable test data)**:
```javascript
const validUser = { id: 1, email: 'user@example.com', name: 'John' };
const invalidUser = { id: 2, email: 'invalid@', name: 'Jane' };
```

**Parameterized Tests**:
```javascript
test.each([
  ['valid@example.com', true],
  ['invalid@', false],
  ['no-at-sign.com', false],
])('validates email %s', (email, expected) => {
  expect(validateEmail(email)).toBe(expected);
});
```

## Anti-Patterns to Eliminate

| Anti-Pattern | Problem | Fix |
|--------------|---------|-----|
| Flaky tests | Intermittent failures, unpredictable | Remove randomness, add waits for conditions |
| Slow tests | >1 second each | Use mocks, parallelize, optimize queries |
| Brittle tests | Break on refactoring | Test behavior, not implementation details |
| Over-mocking | Unrealistic isolation | Balance unit and integration tests |

## Related Agents

- [`qa`](/agents/qa) - Test strategy and release readiness (different scope)
- [`ci`](/agents/ci) - Test infrastructure and CI pipeline setup
- [`api`](/agents/api) - API testing and contract validation
- [`ui`](/agents/ui) - Component testing and user interaction testing
- [`database`](/agents/database) - Data layer testing and query optimization

## Coordination

The Testing Agent coordinates with other agents:

- **AG-API**: Ensure API error cases are tested
- **AG-UI**: Coordinate on component and E2E testing
- **AG-DATABASE**: Test data layer and query performance
- **AG-CI**: Request test infrastructure (parallel execution, coverage reporting)
- **AG-QA**: Align on quality metrics and test coverage targets

## Slash Commands

- `/agileflow:verify US-XXXX` - Run tests for specific story
- `/agileflow:research:ask TOPIC=...` - Research test patterns
- `/agileflow:ai-code-review` - Review test code for anti-patterns
- `/agileflow:adr-new` - Document testing decisions
- `/agileflow:status STORY=... STATUS=...` - Update story status
