# Integrations Expert - Domain Knowledge
# This file is the agent's "mental model" of the integrations domain
# AUTO-UPDATED by self-improve.md after completing work

domain: integrations
last_updated: 2025-12-21
version: 1.1

files:
  clients:
    - path: src/integrations/
      purpose: "Third-party API client implementations"
      key_exports: []
      conventions: "One client per service (StripeClient, TwilioClient)"
    - path: src/integrations/clients/
      purpose: "API client classes for external services"
      conventions: "Named *Client.ts"
    - path: src/integrations/webhooks/
      purpose: "Webhook receivers and handlers"
      conventions: "Named *WebhookHandler.ts"

  configuration:
    - path: src/config/integrations.ts
      purpose: "Integration configuration and API key management"
      conventions: "All secrets from environment variables"
    - path: .env.example
      purpose: "Template for required environment variables"
      conventions: "Document all integration API keys here"

  types:
    - path: src/types/integrations/
      purpose: "TypeScript types for external service responses"
      conventions: "Match external API response schemas"

  services:
    - path: src/services/payment/
      purpose: "Payment processing service layer"
      conventions: "Wraps Stripe/PayPal/Square clients"
    - path: src/services/email/
      purpose: "Email delivery service layer"
      conventions: "Wraps SendGrid/Mailgun/SES"
    - path: src/services/auth/
      purpose: "Authentication provider integrations"
      conventions: "OAuth flows for Google/GitHub/Auth0"

relationships:
  - parent: services
    child: clients
    type: uses
    notes: "Service layer uses API clients"
  - parent: webhooks
    child: services
    type: triggers
    notes: "Webhooks trigger service layer actions"
  - parent: api_endpoints
    child: services
    type: calls
    notes: "API endpoints call integration services"

patterns:
  - name: API Client Pattern
    description: "Wrap third-party SDK with custom client for testability"
    location: src/integrations/clients/
    example: |
      class StripeClient {
        constructor(apiKey: string) { ... }
        async createPayment(amount: number) { ... }
      }

  - name: Webhook Handler Pattern
    description: "Validate signature, parse event, handle idempotently"
    location: src/integrations/webhooks/
    example: |
      1. Validate webhook signature
      2. Check if event already processed (idempotency)
      3. Parse and route to handler
      4. Respond 200 immediately

  - name: Retry with Exponential Backoff
    description: "Retry failed external requests with increasing delays"
    location: src/integrations/clients/
    example: "1s, 2s, 4s, 8s delays with jitter"

  - name: Circuit Breaker
    description: "Stop calling failing services to prevent cascade failures"
    location: src/integrations/clients/
    example: "Open circuit after 5 consecutive failures"

  - name: Rate Limiting
    description: "Respect external service rate limits"
    location: src/integrations/clients/
    example: "Token bucket or queue-based rate limiting"

conventions:
  - "NEVER hardcode API keys - use environment variables"
  - "ALWAYS validate webhook signatures before processing"
  - "ALWAYS implement retry logic with exponential backoff"
  - "ALWAYS log external service calls (without secrets)"
  - "ALWAYS handle rate limiting gracefully"
  - "Implement idempotency for webhook handlers"
  - "Use circuit breaker for unreliable services"
  - "Mock external services in tests"
  - "Document all required environment variables"

integrations_catalog:
  payment:
    - name: Stripe
      env_vars: [STRIPE_API_KEY, STRIPE_WEBHOOK_SECRET]
      webhooks: [payment.completed, subscription.updated, refund.created]
    - name: PayPal
      env_vars: [PAYPAL_CLIENT_ID, PAYPAL_CLIENT_SECRET]
    - name: Square
      env_vars: [SQUARE_ACCESS_TOKEN]

  email:
    - name: SendGrid
      env_vars: [SENDGRID_API_KEY]
      webhooks: [email.delivered, email.bounced, email.complained]
    - name: Mailgun
      env_vars: [MAILGUN_API_KEY, MAILGUN_DOMAIN]

  auth:
    - name: Auth0
      env_vars: [AUTH0_DOMAIN, AUTH0_CLIENT_ID, AUTH0_CLIENT_SECRET]
    - name: Google OAuth
      env_vars: [GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET]
    - name: GitHub OAuth
      env_vars: [GITHUB_CLIENT_ID, GITHUB_CLIENT_SECRET]

  messaging:
    - name: Twilio
      env_vars: [TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN]
      webhooks: [message.delivered, message.failed]

  storage:
    - name: AWS S3
      env_vars: [AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_S3_BUCKET]
    - name: Google Cloud Storage
      env_vars: [GCS_PROJECT_ID, GCS_BUCKET]

# Learnings are AUTO-UPDATED by self-improve.md
# Do not edit manually - let the agent learn from experience
learnings:
  - title: "IDE Integration Pattern: Multi-Platform Configuration"
    date: 2025-12-21
    context: "AgileFlow supports 3 different IDEs (Claude Code, Cursor, Windsurf) with different config directory structures"
    learning: |
      IDE integrations require platform-specific installers that handle different configuration locations:
      - Claude Code: `.claude/commands/` for slash commands
      - Cursor: `.cursor/commands/` for slash commands
      - Windsurf: `.windsurf/commands/` for slash commands

      Implementation approach:
      1. Create IDE-specific installer scripts in `installers/ide/` directory
      2. Each installer knows its target config directory structure
      3. Use shared installation logic with IDE-specific paths
      4. Test each installer independently

      Key files: `installers/ide/install-claude-code.js`, `install-cursor.js`, `install-windsurf.js`
    impact: "Enables AgileFlow to work across multiple development environments without manual configuration"

  - title: "npm Registry Integration via GitHub Actions"
    date: 2025-12-21
    context: "AgileFlow automates publishing to npm registry when git tags are pushed"
    learning: |
      GitHub Actions can automate npm publishing with proper token management:
      1. Store NPM_TOKEN in GitHub Secrets (repo settings)
      2. Create workflow triggered by tag push pattern `v*.*.*`
      3. Verify version consistency before publishing
      4. Use `npm publish --access public` for public packages

      Critical checks in workflow:
      - Extract version from git tag
      - Verify package.json version matches tag
      - Verify CHANGELOG.md has release notes for version
      - Install dependencies if package-lock.json exists
      - Publish with NPM_TOKEN authentication

      Key file: `.github/workflows/npm-publish.yml`
    impact: "Eliminates manual publishing errors and ensures consistent release process"

  - title: "Dynamic Content Injection at Install Time"
    date: 2025-12-21
    context: "AgileFlow uses placeholders in source files that get replaced with current content during installation"
    learning: |
      Dynamic content injection pattern avoids maintenance overhead for lists that change frequently:

      Source files use placeholders:
      - `<!-- {{AGENT_LIST}} -->` - Gets replaced with current agent list
      - `<!-- {{COMMAND_LIST}} -->` - Gets replaced with current command list
      - `<!-- {{SKILL_LIST}} -->` - Gets replaced with current skill list

      Installer scans source files during installation and:
      1. Detects placeholder patterns
      2. Generates current list from filesystem (e.g., scan agents/ directory)
      3. Replaces placeholder with formatted list
      4. Writes installed file with injected content

      Benefits:
      - Zero maintenance overhead (no manual list updates)
      - Always current (generated at install time)
      - Source files stay clean and simple
      - Installed files have complete information

      Used in: babysit.md, expert.md, and other command files
    impact: "Reduces maintenance burden and prevents stale documentation"

  - title: "CI/CD Integration: Automated Release Workflow"
    date: 2025-12-21
    context: "AgileFlow uses release script + GitHub Actions for end-to-end release automation"
    learning: |
      Complete CI/CD integration requires coordinating multiple systems:

      1. Local automation (release.sh script):
         - Version bumping across multiple package.json files
         - Git commit and tag creation
         - GitHub release creation via `gh` CLI

      2. Remote automation (GitHub Actions):
         - Triggered by tag push
         - Version verification (tag matches package.json)
         - CHANGELOG verification (release notes exist)
         - npm publishing with token authentication

      3. Integration points:
         - Git tags trigger GitHub Actions workflows
         - GitHub Secrets provide secure token storage
         - Workflow status appears in GitHub UI
         - npm registry reflects published version

      Key insight: Split concerns between local (developer workflow) and remote (publishing) automation
      Key files: `scripts/release.sh`, `.github/workflows/npm-publish.yml`
    impact: "Provides reliable, repeatable release process that reduces human error"
